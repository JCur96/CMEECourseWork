Starting weekly assessment for Jake, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 48.03 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week4, .git, Week3, Project, HPC_week, MiniPorject

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
# .gitignore containing python and LaTeX templates, plus my own rules

# Python template for .gitignore

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# LaTeX template

## Core latex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.fls
*.out
*.toc
*.fmt
*.fot
*.cb
*.cb2
.*.lb

## Intermediate documents:
*.dvi
*.xdv
*-converted-to.*
# these rules might exclude image files for figures etc.
# *.ps
# *.eps
# *.pdf

## Generated if empty string is given at "Please type another file name for output:"
.pdf

## Bibliography auxiliary files (bibtex/biblatex/biber):
*.bbl
*.bcf
*.blg
*-blx.aux
*-blx.bib
*.run.xml

## Build tool auxiliary files:
*.fdb_latexmk
*.synctex
*.synctex(busy)
*.synctex.gz
*.synctex.gz(busy)
*.pdfsync

## Build tool directories for auxiliary files
# latexrun
latex.out/

## Auxiliary and intermediate files from other packages:
# algorithms
*.alg
*.loa

# achemso
acs-*.bib

# amsthm
*.thm

# beamer
*.nav
*.pre
*.snm
*.vrb

# changes
*.soc

# comment
*.cut

# cprotect
*.cpt

# elsarticle (documentclass of Elsevier journals)
*.spl

# endnotes
*.ent

# fixme
*.lox

# feynmf/feynmp
*.mf
*.mp
*.t[1-9]
*.t[1-9][0-9]
*.tfm

#(r)(e)ledmac/(r)(e)ledpar
*.end
*.?end
*.[1-9]
*.[1-9][0-9]
*.[1-9][0-9][0-9]
*.[1-9]R
*.[1-9][0-9]R
*.[1-9][0-9][0-9]R
*.eledsec[1-9]
*.eledsec[1-9]R
*.eledsec[1-9][0-9]
*.eledsec[1-9][0-9]R
*.eledsec[1-9][0-9][0-9]
*.eledsec[1-9][0-9][0-9]R

# glossaries
*.acn
*.acr
*.glg
*.glo
*.gls
*.glsdefs

# gnuplottex
*-gnuplottex-*

# gregoriotex
*.gaux
*.gtex

# htlatex
*.4ct
*.4tc
*.idv
*.lg
*.trc
*.xref

# hyperref
*.brf

# knitr
*-concordance.tex
# TODO Comment the next line if you want to keep your tikz graphics files
*.tikz
*-tikzDictionary

# listings
*.lol

# makeidx
*.idx
*.ilg
*.ind
*.ist

# minitoc
*.maf
*.mlf
*.mlt
*.mtc[0-9]*
*.slf[0-9]*
*.slt[0-9]*
*.stc[0-9]*

# minted
_minted*
*.pyg

# morewrites
*.mw

# nomencl
*.nlg
*.nlo
*.nls

# pax
*.pax

# pdfpcnotes
*.pdfpc

# sagetex
*.sagetex.sage
*.sagetex.py
*.sagetex.scmd

# scrwfile
*.wrt

# sympy
*.sout
*.sympy
sympy-plots-for-*.tex/

# pdfcomment
*.upa
*.upb

# pythontex
*.pytxcode
pythontex-files-*/

# tcolorbox
*.listing

# thmtools
*.loe

# TikZ & PGF
*.dpth
*.md5
*.auxlock

# todonotes
*.tdo

# easy-todo
*.lod

# xcolor
*.xcp

# xmpincl
*.xmpi

# xindy
*.xdy

# xypic precompiled matrices
*.xyc

# endfloat
*.ttt
*.fff

# Latexian
TSWLatexianTemp*

## Editors:
# WinEdt
*.bak
*.sav

# Texpad
.texpadtmp

# LyX
*.lyx~

# Kile
*.backup

# KBibTeX
*~[0-9]*

# auto folder when using emacs and auctex
./auto/*
*.el

# expex forward references with \gathertags
*-tags.tex

# standalone packages
*.sta

# R gitignore

# History files
.Rhistory
.Rapp.history

# Session Data files
.RData

# Example code in package build process
*-Ex.R

# Output files from R CMD build
/*.tar.gz

# Output files from R CMD check
/*.Rcheck/

# RStudio files
.Rproj.user/

# produced vignettes
vignettes/*.html
vignettes/*.pdf

# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth

# knitr and R markdown default cache directories
/*_cache/
/cache/

# Temporary files created by R markdown
*.utf8.md
*.knit.md

# Shiny token, see https://shiny.rstudio.com/articles/shinyapps.html
rsconnect/


# Anything extra I've thought of

*~
*.tmp
find . -size +100M | cat


**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository

Getting Started 
All work has been conducted in Ubuntu 18.04.1 LTS (Bionic Beaver). 

Intro - 
Computational Methods in Ecology and Evolution (or CMEE) is a one year masters course, this repository is the coursework generated as part of that masters. 
Each week is split into a seperate directory, labelled as such (e.g. Week1), which is in turn split into four sub directories (Code, Data, Output and Sandbox). The titles for each are fairly self explanatory, with Code containing any code written (be it scripts, bash commands or otherwise), Data contains raw data, Output containing any relevant outputs that want to be saved, and Sandbox is a place for playing with new code and files. 

Why the Git? 
This git is used to push each weeks work to by 5pm Wednesday of the following week for marking. 

Author: Jake Curry, j.curry18@imperial.ac.uk 
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 8 weekly directories: HPC_week, Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
Readme file for week2 (Python 1!)

This week is Python I, so going through the basics o fthis language, 

Directories: Code, Data, Results and Sandbox 


Code:
align_seqs.py - aligns DNA sequences from an input file then ouptuts the best alignment and its score to a results file called BestMatch.txt in Results! 

basic_csv.py - python script for opening and reading a csv file containing species and body mass data, and subsequently creating a file containing only species name and body mass.

basic_io.py - First python script I've written, reads a basic text file, and demonstrates various 
loop functions that can be written in python to edit the text file.

boilerplate.py - A basic boilerplate program for python! Prints the statement 'This is a boilerplate' after importing the sys module, and closes the program once its done

cfexercises1.py - Some functions exemplifying control statements

cfexercises2.py - Some more functions exemplifying control statements

control_flow.py - Even more functions exemplifying control statements

debugme.py - Creates a program with a bug, then lets you debug it!

dictionary.py - Making a dictionary from a list 

lc1.py - Using list comprehension and traditional loops to make lists from a nested tuple

lc2.py - Using list comprehension to create lists of tuples

loops.py - loops in python

oaks.py - Examples of list comprehension in python vs loops

oaks_debugme.py - Debugging the oaks script using break points and doc testing

scope.py - Demonstrates local and global variables 

sysargv.py - Demonstrates system argument

test_control_flow.py - Testing using doctests

tuple.py - Printing elements of a tuple on new lines and removing the brackets to make it look prettier

using_name.py - Using modules. Can be run as a self standing program or imported from another module - it tells you which it's doing!

Data:
JustOaksData.csv - The output of oaks_debugme.py 

TestOaksData.csv - the input of oaks_debugme.py

bodymass.csv - the output file for basic_csv.py

seqs.csv - the input file for align_seqs.py

testcsv.csv - the input file for basic_csv

Results:
BestMatch.txt - the output for align_seqs.py


Sandbox:
temporarytxt.txt - file made when testing code blocks

test.txt - input file for basic_io.py

testout.txt - output file for basic_io.py

testp.p - output file from pickle in basic_io.py

**********************************************************************

Found following files in results directory: BestMatch.txt...

Found 19 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, dictionary.py, debugme.py, scope.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, sysargv.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Using list comprehension to create lists of tuples """

__appname__ = 'lc2.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) 
mrethn100 = list ([i for i in rainfall if i[1]>100]) # list comprehension to create a list of month names and rainfall data where the amount of rain 
# was more than 100mm. List function tells python to create a kind of list, i, is a place-
# holder for all the variables in this original tuple, with [0] defining the first
# variable in the tuple. 
# for loops through all the 
# variables, the if statement determines which tuples are of interest for the 
# new list (in this case those where the second part of the tuple is less than 50)
print(mrethn100) # print displays the new set

# (2) 
lssthn50 = list ([i[0] for i in rainfall if i[1]<50 ]) # list comprehension to create a list of just month names where the amount of rain 
# was less than 50mm. List function tells python to create a kind of list, i, is a place-
# holder for all the variables in this original tuple, with [0] defining the first
# variable in the tuple. 
# for loops through all the 
# variables, the if statement determines which tuples are of interest for the 
# new list (in this case those where the second part of the tuple is less than 50)
print(lssthn50) # print displays the new set
 
# (3)
mt1_loop = set()
for i in rainfall:
    if i[1]>100: # mathematical notation (i.e. >, <, works in python for rule creation as part of the if statement)
        mt1_loop.append(i) # the .append statement tells the loop to add elements which meet
# the requirements of the if statement to the newly created list. 
print(mt1_loop)



lt50_loop = set ()
for i in rainfall:
    if i[1]<50:
        lt50_loop.append(i[0])
print(lt50_loop)
 
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "lc2.py", line 50, in <module>
    mt1_loop.append(i) # the .append statement tells the loop to add elements which meet
AttributeError: 'set' object has no attribute 'append'

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""A basic boilerplate program for python! Prints the statement 'This is a boilerplate'
    after importing the sys module, and closes the program once its done"""
__appname__ = 'boilerplate.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ## 

## functions ## 
def main(argv): 
    """Main entry point of the program """
    print('This is a boilerplate') #NOTE: indented using two tabs of 4 spaces
    return 0
    
if __name__=="__main__": 
    """Makes sure the "main" fuction is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02794s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Python script for opening and reading a csv file containing species and body mass data, 
 and subsequently creating a file containing only species name and body mass"""
__appname__ = 'basic_csv.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

# imports 
import csv # importing a module for use in this script - much like packages in R
# Read a file containing: 
# 'Species', 'Infraorder', 'Family', 'Distribution', 'Body mass (Kg)' 
f = open('../Data/testcsv.csv', 'r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])
f.close()

# Write a file containing only species name and Body mass
f = open('../Data/testcsv.csv', 'r')
g = open('../Data/bodymass.csv', 'w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03063s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying control statements"""
__appname__ = 'cfexercises2.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ## 
import sys

""" give the input to the power of 0.05"""
def foo1(x):
    return x ** 0.5 

""" returns the greater of the inputs"""
def foo2(x, y):
    if x > y:
        return x
    return y 

""" returns the input in order of lowest to highest """
def foo3(x, y, z):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]   

""" calculates factorial iteratively """
def foo4(x): 
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result # runs through the range multipying result by each number in the range

"""a recursive function - calls itself until it hits 1"""
def foo5(x): 
    if x == 1:
        return 1
    return x * foo5(x - 1) # input times by this function but for input minus one until it hits one

"""Calculate the factorial of x in a different way"""
def foo6(x): 
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto

def main(argv): # defines what main is (argv translates as variable)
    print(foo1(5)) # these statements are here to show that each function works
    print(foo2(1,2))
    print(foo3(2,7,4))
    print(foo4(11))
    print(foo5(10))
    print(foo6(5))
    return 0 # returns 0 on successful run after printing the above


if (__name__=="__main__"): 
    """Makes sure the "main" fuction is called from command line"""
    status = main(sys.argv) # makes the status equal to the system variable/argument
    sys.exit # explicitly exits to the system

**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
2.23606797749979
2
[2, 4, 7]
39916800
3628800
120

**********************************************************************

Code ran without errors

Time consumed = 0.03056s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Making a dictionary from a list """

__appname__ = 'dictionary.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

# Write your script here:

# can be written as a dictionary comprehension - the below is partially complete
# it requires resolving the no copies of keys issue, which I couldn't find
# taxa_dict = {key: value for (value, key) in taxa} ## Using list (dictionary) comprehension to make a dictionary, 
# where species (values) are mapped to orders (keys)
# print(taxa_dict)

## The below works, but it is a loop 

from collections import defaultdict ## importing the subclass defaultdict from the collections module, which
# provides an alternative to dict, allowing for lists to be turned into dictionaries directly
taxa_dic = defaultdict(list)
for v, k in taxa: # v and k are stand ins for values and keys respectively
    taxa_dic[k].append(v) # adds values to the keys the correspond to, prevents deletion of duplicate key:value pairs, 
    # as it appends the value of a duplicate key to the already existing key
print(taxa_dic) # prints the dictionary, allowing verification that this has worked

for key in taxa_dic:
        print(taxa_dic[key])
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
defaultdict(<class 'list'>, {'Chiroptera': ['Myotis lucifugus'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus']})
['Myotis lucifugus']
['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus']
['Microgale dobsoni', 'Microgale talazaci']
['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomy
**********************************************************************

Code ran without errors

Time consumed = 0.02437s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Creates a program with a bug, then lets you debug it!"""

__appname__ = 'debugme.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"



def createabug(x):
    y = x**4
    z = 0.1
    y = y/z
    return y

createabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03486s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Demonstrates local and global variables """

__appname__ = 'scope.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


## Try this first
_a_global = 10

def a_function():
    _a_global = 5 
    _a_local = 4 
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value  is ", _a_local)
    return None

a_function()

print("Outside the function, the value is ", _a_global)

## Now try this 

_a_global = 10 

def a_function():
    global _a_global
    _a_global = 5 
    _a_local = 4 
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()
print("Outside the function, the value is ", _a_global)**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value  is  4
Outside the function, the value is  10
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  5

**********************************************************************

Code ran without errors

Time consumed = 0.02973s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying control statements"""
__appname__ = 'cfexercises1.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

for i in range(3, 17):
    print('hello')

for j in range(12):
    if j % 3 == 0:
        print('hello')

for j in range(15):
     if j % 5 == 3:
        print('hello')
     elif j % 4 == 3:
        print('hello')

z = 0
while z != 15:
    print('hello')
    z = z + 3

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1

**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02891s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Printing elements of a tuple on new lines and removing the brackets to make it look prettier """

__appname__ = 'tuple.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )



for i in birds: # i is a placeholder for all elements in birds, for makes a loop that goes through 
    # all elements 
    print("{} {} {}".format (i[0], i[1], i[2])) # print displays all elements found in birds, each tuple is displayed on 
    # a new line. .format allows for the removal of the brackets, making it a little 
    # prettier

**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Passerculus sandwichensis Savannah sparrow 18.7
Delichon urbica House martin 19
Junco phaeonotus Yellow-eyed junco 19.5
Junco hyemalis Dark-eyed junco 19.6
Tachycineata bicolor Tree swallow 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.02886s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""First python script I've written, reads a basic text file, and demonstrates various 
loop functions that can be written in python to edit the text file. """
__appname__ = 'basic_io.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

##############
# FILE INPUT
#############
# Open a file for reading
f = open('../Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip the blank lines 
f = open('../Sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) >0:
        print(line)

f.close()

##############
# FILE OUTPUT 
##############
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../Sandbox/testout.txt', 'w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()

######################
# STORING OBJECTS
######################
# To save an object (even complex) for later use 
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../Sandbox/testp.p', 'wb') ## note the b: accpet binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again 
f = open('../Sandbox/testp.p', 'rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)
**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line

First Line

Second Line

Third Line

Fourth Line

{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.03258s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python 3
""" Using list comprehension and traditional loops to make lists from a nested tuple""""
__appname__ = 'lc1.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

        
#(1) Using list comprehension to create three seperate lists, of Latin name, common name and body mass respectively
latin_name_lc = list ([i[0] for i in birds])   # The function list tells python that we are creating a list from the enclosed command
# which say for every element of this nested tuple, use the first (zero) tuple to create
# the new list.
print (latin_name_lc) # Print jsut shows whats in the list. Each new block is for a different list 
# with [] being used to select which element of the nested tuple to use to create the list

common_name_lc = list ([i[1] for i in birds])
print (common_name_lc)

weight_lc = list ([i[2] for i in birds])
print (weight_lc)

# (2) Using loops to create three seperate lists
latin_name_loop = list() # list is a function used to create lists. 
for i in birds:
    latin_name_loop.append(i[0]) # The loop goes through the tuple, birds, finding the 
# specified element (first[0], second[1] or third[2] 
# # depending on which new list is being created) and .appends (adds) it to the new list. 
print(latin_name_loop) # Once this is done print displays the content of each list.


common_name_loop = set()
for i in birds:
    common_name_loop.append(i[1])
print(common_name_loop)

weight_loop = set()
for i in birds:
    weight_loop.append(i[2])
print(weight_loop)


**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
  File "lc1.py", line 2
    """ Using list comprehension and traditional loops to make lists from a nested tuple""""
                                                                                           ^
SyntaxError: EOL while scanning string literal

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Debugging the oaks script using break points and doc testing """

__appname__ = 'oaks_debugme.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"
 
# Imports
import doctest
import csv
import sys



#Define function - doctests go here
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus'
    >>> is_an_oak("Quercus robur")
    True

    >>> is_an_oak("Fagus slyvatica")
    False

    testing to see if just genus gives a good result    
    >>> is_an_oak("Quercus")
    True
   
    >>> is_an_oak("Quercuss") 
    False

    >>> is_an_oak("QUERCUS")
    True

    >>> is_an_oak("quercusstart") 
    False

    >>> is_an_oak(" quercus") 
    True

    >>> is_an_oak(1)
    False 
    
    """
    name = str(name).lower() # converts to a string and lower case
    name = name.lstrip() # removes and blank space on the left
    name = name.split(" ")[0] # splits strings at spaces
    if len(name) !=7: # for strings longer than just quercus will return false 
         return False
    return name.startswith("quercus")

    doctest.testmod()

def main(argv): 
    """ Opens the data sheet, and a results sheet
    makes a set containing the oaks in the dataset
    prints all results on a new line 
    prints FOUND AN OAK every time an oak is found 
    writes oaks found to the results data sheet"""
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    skip_header = next(taxa) # skips to the second row
    oaks = set()
    if skip_header: # writes in a header if you skipped it previously
            csvwrite.writerow(skip_header) 
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print("FOUND AN OAK!\n")
            csvwrite.writerow([row[0], row[1]])  
        

    return 0



if (__name__ == "__main__"):
    status = main(sys.argv)**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!

['1', ' 2']
The genus is: 
1


**********************************************************************

Code ran without errors

Time consumed = 0.06310s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Examples of list comprehension in python vs loops"""
__appname__ = 'oaks.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}

**********************************************************************

Code ran without errors

Time consumed = 0.03009s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""loops in python"""
__appname__ = 'loops.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

# FOR loops in Python
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops  in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.25968s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3 
""" Using modules. Can be run as a self standing program or imported from another module - it tells you which it's doing! """
__appname__ = 'using_name.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = 'license for this software would go here'

# Filename: using_name.py
if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07087s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Aligns two DNA sequences from a single input file and sends the best match to a single output file 
Modularising functions requires that input arguments are given as well as output arguments e.g. def function (arg, arg2 ect..)
return outarg1, outarg2 etc"""

__appname__ = 'align_seqs.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


# Two example sequences to match
# seq2 = "ATCGCCGGATTACGGG"
# seq1 = "CAATTCGGAT"

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest
import sys
import csv

##     



def inreading(lines):
    """ reads files in and makes sure the sequence lengths are correct way round
    by  assigning each sequence to either seq1 or seq2 """
    # D = open(seqfile)
    # lines = D.readlines()
    # D.close 
    seq1 = lines[0].rstrip("\n")
    seq2 = lines[1].rstrip("\n")

    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths
    return s1, s2, l1, l2

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """ calculates the score of how many bases in the sequences match"""
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output from making sure the code does what was expected
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score


# Test the function with some example starting points:
    # calculate_score(s1, s2, l1, l2, 0)
    # calculate_score(s1, s2, l1, l2, 1)
    # calculate_score(s1, s2, l1, l2, 5)
            

# now try to find the best match (highest score) for the two sequences
def best_match(s1, s2, l1, l2):
    """ calculates the best alignment i.e. with the highest score """
    my_best_align = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 # think about what this is doing!
            my_best_score = z 
    return my_best_align, my_best_score


def main(argv):
    """ Reads a single csv file and extracts the data
    then parses through, functions for sequence length,
    alignment and score. Then outputs best alignment, the longest sequence and the best score to a txt file"""
    with open("../Data/seqs.csv", "r") as infile:  
        inreader = csv.reader(infile) # make a reader instance for infile, reads lines in 
        source_data = [x[0] for x in inreader] # makes a list out of the contents of the .reader object
    source_data = source_data[0:2] # Makes sure only the first two lines in the file are used
    print(source_data)
    s1, s2, l1, l2 = inreading(source_data) # calling from inreading function above 
    my_best_align, my_best_score = best_match(s1, s2, l1, l2) # calling from the modularised best_match function
    out_str = "{}\n{}\nBest Score: {}\n".format(my_best_align, s1, my_best_score) # turning the outputs into a string
    with open("../Results/BestMatch.txt", "w") as outfile:
        outfile.write(out_str)
    print(out_str)


if (__name__ == "__main__"):
    status = main(sys.argv) 
    sys.exit**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['ATCGCCGGATTACGGG', 'CAATTCGGAT']
CAATTCGGAT
ATCGCCGGATTACGGG
Best Score: 5


**********************************************************************

Code ran without errors

Time consumed = 0.05647s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" Demonstrates system argument """

__appname__ = 'sysargv.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

import sys
print('This is the name of the script', sys.argv[0])
print('Number of arguments: ', len(sys.argv))
print('The arguments are: ', str(sys.argv))**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is the name of the script sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02175s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying control statements"""
__appname__ = 'control_flow.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ## 

## functions ## 
def even_or_odd(x=0): # if not specified x should take value 0

    """ Find whether a number x is even or odd """
    if x % 2  == 0: # the conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x
def largest_divisor_five(x=120): 
    """Find which is the largest divisor of x amoung 2,3,4,5."""
    largest = 0 
    if x % 5 == 0: 
        largest = 5 
    elif x % 4 == 0: ## means else if, part of the if/or/else function statement family
        largest = 4 
    elif x % 3 == 0: 
        largest = 3 
    elif x % 2 == 0:
        largest = 2
    else: #Used last as for when all other elif conditions not met
        return "No divisor found for %d!" % x # Each function can return a value or variable
    return "The largest divisor of %d is %d" % (x, largest)        

def is_prime(x=70):
    """Finds whether an integer is prime."""
    for i in range(2, x): # range returns a sequence of integers
        if x  % i == 0: 
            print("%d is not a prime: %d is a divisor" % (x, i))
            # Print formatted text "%d %s %f %e" % (20, "30", 0.0003,0.00003)

            return False
    print("%d is a prime!" % x)
    return True

def find_all_primes(x=22):
    """Find all primes up to x"""
    allprimes = []
    for i in range(2, x + 1): 
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0 
    
if (__name__=="__main__"): 
    """Makes sure the "main" fuction is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02923s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Testing using doctests"""

__appname__ = 'test_control_flow.py'
__author__ = 'Jake Curry (j.curry18@imperial.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
    
    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'
    
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    #Define function to be tested
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### Suppressed as not interested in input/output right now #######

# def main(argv): 
    # print even_or_odd(22)
    # print even_or_odd(33)
    # return 0

# if (__name__ == "__main__"):
    # status = main(sys.argv)
#############################################
    
doctest.testmod()   # To run with embedded tests**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06933s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!